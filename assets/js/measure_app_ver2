(()=>{ //即時関数に入れる
  //***********DOM要素類↓↓↓↓↓ */
  const arg1 = {capture: false, once: false, passive: false};
  const $can = document.getElementById('c1');
  const $ctx = $can.getContext('2d');
  const $doc = document;
  const $Label = $doc.getElementsByClassName('test');
  const $clear = $doc.getElementsByClassName('allClear');
  const $pop_up = $doc.getElementsByClassName('hContent popUp');
  const $init_label = $doc.getElementsByClassName('init_setting_label');
  const $pop_label = $doc.getElementsByClassName('popUpLabel');
  const $set_dir = $doc.getElementsByClassName('select_direct');
  const $init_Val = $doc.getElementById('initial_value');
  const $SetButton = $doc.getElementsByClassName('button-setting_content');
  const $MeasureTrriger = $doc.getElementsByClassName('MeasureTriger');
  const $CancelTrriger = $doc.getElementsByClassName('cancel_trriger');
  const $init_set =$doc.getElementsByClassName('initial_setting');
  const $can_label =$doc.getElementsByClassName('canvas_label');
  //*初期設定、測定トリガー用******************
  const ACTIVATE_='is-active';
  let measure_trriger = 0;
  let init_setting = 0;
  let init_click_index = 0;
  let init_direction='null';
  let init_value_;
  let init_prevent_index = 0;
  let lean = 0;
  //*************************** */
  //測定結果格納用//
  const $measure = document.getElementsByClassName('Measure_label');
  const $measure_len = $measure.length;
  const $data_masure = document.querySelectorAll('[data-measure]');
  //*******************↑↑↑↑↑ */
  //画像の情報を保管しておく変数↓↓↓↓↓
  let judge_img =0; // 0->まだ画像登録なし。1->すでに画像登録あり。
  let img0 = null;
  let img1 = null;
  let files = null;
  let file = null;
  let reader = null;
  let item = null;
  let img1_event_target = null;
  //**************************↑↑↑↑↑*/
  //****線を書くために必要な変数/定数↓↓↓↓↓ */
  let click_index=0;
  let x_start =0;
  let y_start =0;
  let x_end =0;
  let y_end =0;
  let position_index1 =[x_start ,y_start,x_end, y_end, 0,0,0,0]; //[x_start ,y_start,x_end, y_end, クリックされた回数,ラベルのｘ、ラベルのｙ,move_triger]
  let position_index2 =[[x_start ,y_start,x_end, y_end, 0,0,0,0]];
  let init_position1 = [x_start ,y_start,x_end, y_end,0];
  let init_position2 = [x_start ,y_start,x_end, y_end,0];
  const ballRadius = 4;
  //*******************************↑↑↑↑↑ */
  //***測定結果を書くための変数/定数 */
  let targetVal = 100;
  let measurement_cnt =0;
  let move_index_number =[];
  let set_move_index_number;
  let measure_data_label_cnt = 0;
  //********************************** */
  //*****Canvasサイズを全体にするための定数 */
  const canvas_width = document.documentElement.clientWidth - 38;
  const canvas_height = document.documentElement.clientHeight - 10;
  //************************************************************ */
  //**********************canvasのサイズをwindowサイズに合わせる関数******************************
  function fitCanvasSize() {
    // Canvas のサイズをクライアントサイズに合わせる
    $can.width = canvas_width;
    $can.height = canvas_height;
  
  }  
  fitCanvasSize();
  window.onresize = fitCanvasSize;
  //**************************************************************************************** */


  const dragOverHandler = {
    handleEvent: (event) => {
      judge_img=0; //再貼り付けする際にカウンターを０に戻すための再定義
      event.dataTransfer.dropEffect = 'copy';
      event.preventDefault();
    }
  };  $can.addEventListener('dragover', dragOverHandler, arg1);        

  const dropHandler =(event)=> {
    files = event.dataTransfer.files;
    if (files.length === 1) {
      file = files[0];
      reader = new FileReader();
      reader.addEventListener('load', loadReaderHandler, arg1);
      reader.readAsDataURL(file);
    }
    event.preventDefault();
    
  };  $can.addEventListener('drop',(arg1)=>{dropHandler(event);});

  const drawCanvasHandler = {
    handleEvent: (event) => {
      if (judge_img ===0){
        img0 = event.target;
        $ctx.drawImage(img0, 0, 0);
        $ctx.save();
        judge_img=1; //命令の最後にジャッジカウントを１にして、再貼り付け可能にしておく
      } else if (judge_img ===1){
        $ctx.drawImage(img0, 0, 0);
        $ctx.save();
      };   
      $can_label[0].style.display = 'none'   
    }
  };

  const loadReaderHandler = {
    handleEvent: (event) => {
      if (judge_img === 0){
        img1 = new Image();
        img1.addEventListener('load', drawCanvasHandler, arg1);
        img1_event_target = img1.src = event.target.result;
      } else if (judge_img === 1){
        img1.addEventListener('load', drawCanvasHandler,arg1);
        img1.src = img1_event_target;
      };     
    }
  };
  //*********************コピペで画像を貼り付けるコード *******************
  document.onpaste = function(pasteEvent) {
    judge_img=0; //再貼り付けする際にカウンターを０に戻すための再定義
    item = pasteEvent.clipboardData.items[0];
    if (item.type.indexOf("image") === 0)
    {
      file = item.getAsFile();
      reader = new FileReader();
      reader.addEventListener('load', loadReaderHandler, arg1);
      reader.readAsDataURL(file);
    }
  }
//*******************************************************************

 //************************:画像をキャンバス上に貼る関数*********************************************
  const can_draw = window.onload = (arrayData)=>{
    let move_index = 0;
    let cnt= 0;
    if (init_setting ===0){
      while(cnt < arrayData.length){
        if(arrayData[cnt][7]===1){
          move_index = 1;
          move_index_number.push(cnt);
        }
        cnt++;
      }
      set_move_index_number = new Set(move_index_number);
      move_index_number = [...set_move_index_number]; 
    };
    
    if(move_index===0){
      if (judge_img === 0){
      } else {
        img1.src = img1_event_target;
        if (init_setting ===1){ //初期設定の時はこっち
          img1.onload = () =>{
            $ctx.clearRect(0, 0,canvas_width,canvas_height);
            $ctx.drawImage(img0, 0, 0)
            if (arrayData[4]%2 === 0){
              $ctx.beginPath () ;
              $ctx.moveTo( arrayData[0], arrayData[1] ) ;
              $ctx.lineTo( arrayData[2], arrayData[3] ) ;
              $ctx.strokeStyle = "blue" ;
              $ctx.lineWidth = 5 ;
              $ctx.stroke() ;
            };

          
            $ctx.beginPath();
            $ctx.arc(arrayData[0]-ballRadius/2, arrayData[1]-ballRadius/2, ballRadius, 0, Math.PI*2);
            $ctx.arc(arrayData[2]-ballRadius/2, arrayData[3]-ballRadius/2, ballRadius, 0, Math.PI*2);
            $ctx.fillStyle = "rgb(0, 183, 255)";
            $ctx.fill();
            $ctx.closePath();
            console.log('init_position1->',init_position1);
            

  
          };
        } else { //測定の時はこっち
          img1.onload = () =>{
            $ctx.clearRect(0, 0,canvas_width,canvas_height);
            $ctx.drawImage(img0, 0, 0)
            let line_index = Math.floor((arrayData[0][4]-1)/2) +1 ;
            let index = 0;
            while (index < line_index){
              $ctx.beginPath () ;
              $ctx.moveTo( arrayData[index][0], arrayData[index][1] ) ;
              if(arrayData[0][4] % 2 === 0){
                $ctx.lineTo( arrayData[index][2], arrayData[index][3] ) ;
              } else if (index < line_index-1){
                $ctx.lineTo( arrayData[index][2], arrayData[index][3] ) ;
              };
              $ctx.strokeStyle = "red" ;
              $ctx.lineWidth = 3 ;
              $ctx.stroke() ;

              $ctx.beginPath () ;
              $ctx.moveTo( (arrayData[index][0]+arrayData[index][2])/2, (arrayData[index][1]+arrayData[index][3])/2 ) ;
              if(arrayData[0][4] % 2 === 0){
                $ctx.lineTo( (arrayData[index][0]+arrayData[index][2])/2-30, (arrayData[index][1]+arrayData[index][3])/2-60 ) ;
              } else if (index < line_index-1){
                $ctx.lineTo( (arrayData[index][0]+arrayData[index][2])/2-30, (arrayData[index][1]+arrayData[index][3])/2-60 ) ;
              };

              // $ctx.strokeStyle = rgb(106, 243, 88) ;
              $ctx.strokeStyle = "red" ;
              $ctx.lineWidth = 1 ;
              $ctx.stroke() ;
              if (arrayData[index][0] !==0){
                $ctx.beginPath();
                $ctx.arc(arrayData[index][0]-ballRadius/2, arrayData[index][1]-ballRadius/2, ballRadius, 0, Math.PI*2);
                if(arrayData[0][4] % 2 === 0){
                  $ctx.arc(arrayData[index][2]-ballRadius/2, arrayData[index][3]-ballRadius/2, ballRadius, 0, Math.PI*2);
                } else if (index < line_index-1) {
                  $ctx.arc(arrayData[index][2]-ballRadius/2, arrayData[index][3]-ballRadius/2, ballRadius, 0, Math.PI*2);
                };
                $ctx.fillStyle = "rgb(253, 10, 221)";
                $ctx.fill();
                $ctx.closePath();
              };
              index++;
            };
  
          };
        }
        
      };
    } else if (move_index ===1){
      img1.src = img1_event_target;
        img1.onload = () =>{
          $ctx.clearRect(0, 0,canvas_width,canvas_height);
          $ctx.drawImage(img0, 0, 0)
          let line_index = Math.floor((arrayData[0][4]-1)/2) +1 ;
          // console.log("関数の中の,,,,,ｘ、ｙ->", arrayData[0], ",", arrayData[1], ",",arrayData[2], ",",arrayData[3], ); //確認用
          let index = 0;
          while (index < line_index){
            $ctx.beginPath () ;
            $ctx.moveTo( arrayData[index][0], arrayData[index][1] ) ;
            if(arrayData[0][4] % 2 === 0){
              $ctx.lineTo( arrayData[index][2], arrayData[index][3] ) ;
            } else if (index < line_index-1){
              $ctx.lineTo( arrayData[index][2], arrayData[index][3] ) ;
            };
            $ctx.strokeStyle = "red" ;
            $ctx.lineWidth = 3 ;
            $ctx.stroke() ;
            $ctx.beginPath () ;
            $ctx.moveTo( (arrayData[index][0]+arrayData[index][2])/2, (arrayData[index][1]+arrayData[index][3])/2 ) ;
            if (move_index_number.includes(index)){
              if(arrayData[0][4] % 2 === 0){
                $ctx.lineTo( arrayData[index][5], arrayData[index][6] ) ;
              } else if (index < line_index-1){
                $ctx.lineTo( arrayData[index][5], arrayData[index][6] ) ;
              };
            } else {
              if(arrayData[0][4] % 2 === 0){
                $ctx.lineTo( (arrayData[index][0]+arrayData[index][2])/2-30, (arrayData[index][1]+arrayData[index][3])/2-60 ) ;
              } else if (index < line_index-1){
                $ctx.lineTo( (arrayData[index][0]+arrayData[index][2])/2-30, (arrayData[index][1]+arrayData[index][3])/2-60 ) ;
              };
            }

            // $ctx.strokeStyle = rgb(106, 243, 88) ;
            $ctx.strokeStyle = "red" ;
            $ctx.lineWidth = 1 ;
            $ctx.stroke() ;
            
            if (arrayData[index][0] !==0){
              $ctx.beginPath();
              $ctx.arc(arrayData[index][0]-ballRadius/2, arrayData[index][1]-ballRadius/2, ballRadius, 0, Math.PI*2);
              if(arrayData[0][4] % 2 === 0){
                $ctx.arc(arrayData[index][2]-ballRadius/2, arrayData[index][3]-ballRadius/2, ballRadius, 0, Math.PI*2);
              } else if (index < line_index-1) {
                $ctx.arc(arrayData[index][2]-ballRadius/2, arrayData[index][3]-ballRadius/2, ballRadius, 0, Math.PI*2);
              };
              $ctx.fillStyle = "rgb(253, 10, 221)";
              $ctx.fill();
              $ctx.closePath();
            };
            index++;
          }

        }
    }
  };

  const measure_data_set = (arrayData)=>{
    $measure[measurement_cnt].style.display = 'block';
    $measure[measurement_cnt].style.left = ((arrayData[measurement_cnt][2]+arrayData[measurement_cnt][0])/2-30)+'px';
    $measure[measurement_cnt].style.top =((arrayData[measurement_cnt][3]+arrayData[measurement_cnt][1])/2-60)+'px';
    $measure[measurement_cnt].innerText = 'x='+((arrayData[measurement_cnt][2]-arrayData[measurement_cnt][0])*lean).toFixed(2)+
                                          '\nY='+((arrayData[measurement_cnt][3]-arrayData[measurement_cnt][1])*lean).toFixed(2)+
                                          '\n直線='+(((arrayData[measurement_cnt][2]-arrayData[measurement_cnt][0])**2+(arrayData[measurement_cnt][3]-arrayData[measurement_cnt][1])**2)**(1/2)*lean).toFixed(2)
    measure_cancel_label_make();
    //MeasureTrriger初期化と測定開始ボタンのis-activeを消す。
    $MeasureTrriger[0].classList.remove(ACTIVATE_);
    PopUpdeleat();
    measure_trriger =0;


  };




  const reset_init_setting =(argData)=>{
    
    $init_set[0].classList.remove(ACTIVATE_);
    if (init_direction ==='x'){
      lean = init_value_/(argData[2]-argData[0]);
    } else if(init_direction ==='y'){
      lean = init_value_/(argData[3]-argData[1]);
    } else if(init_direction ==='Length'){
      lean = init_value_/(((argData[2]-argData[0])**2+(argData[3]-argData[1])**2)**(1/2));
    }
    console.log('lean->',lean)

    PopUpdeleat();
    init_setting =0;
  };

//**********************************************************:*********************************************
//クリックイベント発動時に座標を数字で覚えておく関数 //click_indecxの数字の渡し方なんとかしたい。クリックイベント側とDraw側で渡す数字がずれている。。。。ロジックややこしすぎる
  const handleClick = (e,arrayData)=>{
    let index_check; //初期化の時と、測定の時で配列を変えたので、分岐させている。変えなくてよかったと後悔。
    if (init_setting ===1){
      index_check = arrayData[4];
    } else {
      index_check = arrayData[0][4];
    };

    if(index_check % 2 === 0){ //クリック回数が偶数の時は、スタート点を覚えるだけ。１回目のクリック⇒click_index=0⇒偶数判定
      const rect = e.target.getBoundingClientRect();//画面絶対座標に対するCanvas位置ずれを補正するための定数
      let x_start = event.clientX-rect.left;
      let y_start= event.clientY-rect.top;
      console.log("x,ystart->", x_start,",", y_start);
      console.log('init_setting->',init_setting);
      console.log('click_indexは',click_index);
      click_index = arrayData[0][4];
      let line_index = Math.floor(click_index/2);
      if (init_setting ===1){
        init_click_index++;
      } else {
        click_index++;
      };      
      let fposition;
      if(init_setting === 1){
        fposition = [x_start, y_start,x_end, y_end, init_click_index];
      } else {
        fposition = [x_start, y_start,x_end, y_end, click_index,0,0,0];
      };
      let argData = arrayData;
      if(init_setting === 1){
        argData = fposition;
      } else {
        argData[line_index]=fposition;
      };
      can_draw(argData);
      console.log("fposition",fposition); //fpositionを戻り値としてメインに返す
      return fposition;
    }else{ //クリック回数が奇数の時は、end点を覚えて、キャンバス上に線を書きに行く　can_draw関数に座標を引数として渡す。
      const rect = e.target.getBoundingClientRect();//画面絶対座標に対するCanvas位置ずれを補正するための定数
      let x_end = event.clientX-rect.left;
      let y_end = event.clientY-rect.top;
      click_index=arrayData[0][4];
      let line_index = Math.floor(click_index/2);
      if (init_setting ===1){
        init_click_index++;
      } else {
        click_index++;
      };     
      let fposition;
      if(init_setting === 1){
        fposition = [arrayData[0],arrayData[1],x_end, y_end,init_click_index];
      } else {
        fposition = [arrayData[line_index][0],arrayData[line_index][1],x_end, y_end,click_index,0,0,0];
      };      
      let argData = arrayData;
      if(init_setting === 1){
        argData = fposition;
      } else {
        argData[line_index]=fposition;
      };
      console.log("fposition",fposition);
      console.log("x,yend->", x_end,",", y_end);
      console.log("argData",argData);
      can_draw(argData);
      if(init_setting === 1){
        reset_init_setting(argData);
      } else {
        measure_data_set(argData);
      };
      return fposition;   
    }
  };	
  //クリックイベントを発生させる関数。	
  $can.addEventListener('click', (e)=> {
    if (judge_img === 0){
      // window.alert('画像を貼り付けて下さい');
    } else {
      if(init_setting === 1 && init_prevent_index ===0){
        init_position1 = handleClick(e,init_position2);
        init_position2 = init_position1;
      } else if(measure_trriger===1){//測定ボタンがis-activeの時のみクリックイベントで座標を覚えていく
        position_index1 = handleClick(e,position_index2);           //=の左辺を引数に渡せないため、一度別の変数として受け取り、次行で再代入する
        if((position_index1[4]-1) % 2 ===0){                        //クリック回数が偶数の時*start点(初回を0回目と判定)は
          let line_index = Math.floor((position_index1[4]-1)/2);  //クリック回数の商が取る
          if(line_index < position_index2.length){                //クリック回数の商が０だった場合はそのまま[0]に置き換える
            position_index2[line_index] = position_index1;
            position_index2[0][4] = position_index1[4];         //クリック回数は常に[0][4]に代入する。関数の中で見に行く場所
          }else{                                                  //クリック回数の商が０以外だった場合はpushして新しい行を追加する。
            position_index2.push(position_index1);
            position_index2[0][4] = position_index1[4];         //クリック回数は常に[0][4]に代入する。関数の中で見に行く場所
          };
        } else if ((position_index1[4]-1) % 2 === 1){               //クリック回数が奇数の時*end点(初回を0回目と判定)は line_indexの行にそのまま上書き
          let line_index = Math.floor((position_index1[4]-1)/2);
          position_index2[line_index] = position_index1;
          position_index2[0][4] = position_index1[4];             //クリック回数は常に[0][4]に代入する。関数の中で見に行く場所
        };
      };
    };        
  });

  const measure_data_move = () =>{
    $measure[targetVal].style.left = x+'px';
		$measure[targetVal].style.top = y+'px';
  };
  const move =(e) =>{
    let rect = e.target.getBoundingClientRect() ;
    x = e.clientX - rect.left;
    y = e.clientY - rect.top;
    measure_data_move();
    position_index2[targetVal][5]=x;
    position_index2[targetVal][6]=y;
    position_index2[targetVal][7]=1;
    can_draw(position_index2);
  };


  //キャンセルボタンが押された際に、該当する測定結果のみ削除する。
  const cancel_measurement =(cancelVal)=>{
    position_index2[cancelVal] = [0,0,0,0,position_index2[cancelVal][4],0,0,0];
    $measure[cancelVal].style.display = 'none';
    can_draw(position_index2);
  };

  //測定ラベルに別要素を追加する。
  const measure_cancel_label_make = ()=>{
      let new_cancel_label = $measure[measure_data_label_cnt];
      let new_cancel_element = document.createElement('button');
      console.log('キャンセルボタンを生成しました');
      new_cancel_element.className = 'cancel_trriger';
      new_cancel_element.textContent = '×';
      new_cancel_element.dataset.cancelTrriger = measure_data_label_cnt;
      new_cancel_label.appendChild(new_cancel_element);
      $CancelTrriger[measurement_cnt].style.display = 'block';
      // $CancelTrriger[measurement_cnt].style.left =90+'px';
      // $CancelTrriger[measurement_cnt].style.top =0+'px';
      measurement_cnt++; //measurement_cntは実際はどのタブNo.を押されているかの情報を取ってくる
      new_cancel_element.addEventListener('click', (e)=>{
        const $this = e.target;
        cancelVal = $this.dataset.cancelTrriger;
        if (window.confirm('この測定点を削除しますか？')){
          cancel_measurement(cancelVal);
          console.log('キャンセルします');
        } else {
          console.log('キャンセルしません！！！');
        }            
      });
      measure_data_label_cnt++;
  };

const PopUpdeleat=()=>{
  console.log('init_seting->',init_setting);
  console.log('measure_trriger->',measure_trriger);
  if (init_setting ===1){
  $pop_up[0].style.display = 'none';
  $pop_label[0].style.display = 'none';
  } else if(measure_trriger===1){
  $pop_up[0].style.display = 'none';
  $pop_label[1].style.display = 'none';

  };

};


//方向/数値が入っている状態でOKが押された際に次の表示に切り替える関数
const init_measure = () =>{
  $init_label[0].style.display = 'none';
  $pop_label[0].style.display = 'block';
  init_prevent_index =0;
  console.log('init_direction->',init_direction);
  console.log('init_value_->',init_value_);
};

//初期設定のポップ画面をOK/キャンセルボタンで切り替える関数
const PopUpchange = (e)=>{
  const $this = e.target;
  SetVal = $this.dataset.setbutton;
  console.log('SetVal->',SetVal);
  console.log('$set_dir[0]->',$set_dir[0]);
  if (parseInt(SetVal,10) ===0){
    if ($set_dir[0].value === 'null'){
      window.alert('基準の方向を指定してください');
    } else if (parseInt($init_Val.value,10) === 0){
      window.alert('基準寸法を入力してください');
    } else {
    init_direction=$set_dir[0].value;
    init_value_=$init_Val.value;
    init_measure();
    };  
  } else {
    init_setting =0;
    $pop_up[0].style.display = 'none';
    $init_set[0].classList.remove(ACTIVATE_);
  };
};


//******初期設定ボタンが押された際 
  const handleClick_init_set = (e) =>{
    if (init_setting === 0){
      console.log('初期設定ボタンが押されました。');
      $init_set[0].classList.add(ACTIVATE_);
      $pop_up[0].style.display = 'block';
      $init_label[0].style.display = 'block';
      init_setting =1;
      init_prevent_index =1;
      let cnt=0;
      while(cnt < $SetButton.length){
        $SetButton[cnt].addEventListener('click',(e)=>PopUpchange(e));
        cnt++;
      }  
    };
  };
  $init_set[0].addEventListener('click', (e)=>handleClick_init_set(e));
  //************************************************************************** */

//******測定ボタンが押された際に
  // 1.測定結果用のラベルを動的にHtmlに追加
  // 2.測定ラベルを動かせるように、mousedown,move,mouseupイベントは動的ラベル追加関数の中に入れる
const handleClick_measurement_set = (e) =>{
  if ( measure_trriger === 0 && init_setting===0 && init_direction!=='null'){ //ここに初期設定が入っていなかった場合は受け付けないロジックを後で入れる。Leanの値を見に行くか？？
    $MeasureTrriger[0].classList.add(ACTIVATE_);
    $pop_up[0].style.display = 'block';
    $pop_label[1].style.display = 'block';
    let new_label = document.getElementById('dnd');
    let new_element = document.createElement('label');
    new_element.className = 'Measure_label';
    new_element.innerText = '測定結果'+ measure_data_label_cnt+'\nX\nY\nL';
    new_element.dataset.measure = measure_data_label_cnt;
    new_label.appendChild(new_element);
    // measure_label_make();
    new_element.addEventListener('mousedown', (e)=>{
      const $this = e.target;
      targetVal = $this.dataset.measure;
      console.log('ここは通ってまっせ22222');
      $can.addEventListener('mousemove',move);
    });
    new_element.addEventListener('mouseup', ()=>{
      $can.removeEventListener('mousemove',move);
    });
    measure_trriger =1;
  };
};
$MeasureTrriger[0].addEventListener('click', (e)=>handleClick_measurement_set(e));
//************************************************************************** */

//****************************測定結果をすべて消去
const handleClick_deleat_line = (e) =>{
  let cnt =0;
  while(cnt < position_index2.length){
    position_index2[cnt] = [0,0,0,0,position_index2[cnt][4],0,0,0];
    $measure[cnt].style.display = 'none';
    cnt++;
  }
  can_draw(position_index2);
  console.log('deleatしました');
  console.log('position_index2->',position_index2);
};
$clear[0].addEventListener('click', (e)=>handleClick_deleat_line(e));
//*****************************************************************:: */

//******チェック用の関数、後で消去 */


}) ();


